{"version":3,"file":"dualElement.js","sources":["../../utils/utils.ts","../template.js","../dualElement.ts"],"sourcesContent":["export {\n  isHTMLElement,\n  convertDashToCamel,\n  convertCamelToDash,\n  coupleSettersAndGettersToAttributes,\n  makeElementEditableSanely,\n  findElementInEventPath,\n  changeCss,\n  loadCss,\n}\n\nfunction isHTMLElement(element: unknown): element is HTMLElement {\n  return element instanceof HTMLElement\n}\n\nfunction convertDashToCamel(str: string) {\n  return str.replace(/-([a-z])/g, function(g: string) {\n    return g[1].toUpperCase()\n  })\n}\n\nfunction convertCamelToDash(str: string) {\n  return str.replace(/([a-zA-Z])(?=[A-Z])/g, \"$1-\").toLowerCase()\n}\n\nfunction coupleSettersAndGettersToAttributes(\n  thisObj: HTMLElement,\n  camelCasePropsAsStrings: string[]\n) {\n  for (const propertyName of camelCasePropsAsStrings) {\n    Object.defineProperty(thisObj, propertyName, {\n      get: function() {\n        return this.getAttribute(convertCamelToDash(propertyName))\n      },\n      set: function(value) {\n        return value\n          ? this.setAttribute(convertCamelToDash(propertyName), value)\n          : this.removeAttribute(convertCamelToDash(propertyName))\n      },\n    })\n  }\n}\n\n/*\n * Short version is:\n *   <div\n *     contenteditable=\"true\"\n *     onInput=\"e => console.log('Text inside div', e.currentTarget.textContent)\"\n *   >\n *     Text inside div\n *   </div>\n */\n\nfunction makeElementEditableSanely(\n  element: HTMLElement,\n  callback?: (element: HTMLElement) => void\n) {\n  function makeEditable(event: Event) {\n    element.contentEditable = \"true\"\n    element.blur()\n    element.focus()\n    document.execCommand(\"selectAll\", false, undefined)\n    event.preventDefault()\n    event.stopPropagation()\n    const resetContentEditable = (event: Event) => {\n      element.contentEditable = \"false\"\n      element.removeEventListener(\"keydown\", handleKeyDown)\n      document.removeEventListener(\"click\", handleClickContentEditable)\n      if (typeof callback === \"function\") callback(element)\n    }\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (event.key === \"Tab\") {\n        resetContentEditable(event)\n      }\n    }\n    const handleClickContentEditable = (event: MouseEvent) => {\n      if (event.clientX === 0 && event.clientY === 0) {\n        event.preventDefault()\n        event.stopPropagation()\n      } else resetContentEditable(event)\n    }\n\n    element.addEventListener(\"keydown\", handleKeyDown)\n    document.addEventListener(\"click\", handleClickContentEditable)\n  }\n  element.addEventListener(\"dblclick\", makeEditable)\n  element.addEventListener(\"keydown\", event => {\n    if (event.key === \"Enter\") makeEditable(event)\n  })\n}\n\nfunction findElementInEventPath(\n  event: Event,\n  searchTag: string\n): HTMLElement | null {\n  function predicate(eventTarget: EventTarget, searchTag: string) {\n    if (eventTarget instanceof HTMLElement)\n      return eventTarget.tagName === searchTag\n    else return false\n  }\n  const foundElement = event\n    .composedPath()\n    .find((eventTarget: EventTarget): eventTarget is HTMLElement =>\n      predicate(eventTarget, searchTag)\n    )\n  return foundElement ? foundElement : null\n}\n\nfunction loadCss(path: string, target = document.head) {\n  return new Promise(function(resolve, reject) {\n    const link = document.createElement(\"link\")\n    link.rel = \"stylesheet\"\n    link.href = path\n    target.appendChild(link)\n    link.onload = () => resolve()\n  })\n}\n\nfunction changeCss(element: Element, cssMap: [string, string][]) {\n  if (element instanceof HTMLElement)\n    cssMap.forEach(\n      ([prop, value]: [any, string]) => (element.style[prop as any] = value)\n    )\n  else console.error(`element is not of type HTMLElement`)\n}\n","/**\n * @param {{ [key: string]: any }} opts\n * @returns {string}\n */\n function getCss(opts = {}) {\n  return `:host {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  overflow: auto;\n  width: 12em;\n  height: 3em;\n  border: 0.5px solid darkslategrey;\n  background: linear-gradient(\n    to right,\n    slategrey calc(25% - 4.3px),\n    transparent 0%\n  );\n}\n\ndiv {\n  margin: 0;\n  padding: 0.3em;\n  line-height: 1.3;\n  max-height: 100%;\n  width: 75%;\n  flex: 3 3 30px;\n  overflow-wrap: anywhere;\n  text-align: center;\n  display: inline-block;\n}\n\nbutton {\n  display: inline-block;\n  width: 25%;\n  flex: 1 1 10px;\n  height: 100%;\n  /* background-color: slategrey; */\n  background-image: linear-gradient(\n    to right,\n    rgba(255, 80, 99, 5),\n    rgba(17, 26, 152, 1)\n  );\n  cursor: pointer;\n  outline: none;\n  border: none;\n}\n\nbutton:hover {\n  background-color: darkslategrey;\n}`\n}\n\n/**\n * @param {{ [key: string]: any }} opts\n * @returns {string}\n */\n function getHtml(opts = {}) {\n  return `<button aria-label=\"Settings\"></button>\n<div spellcheck=\"false\">${opts.content}</div>`\n}\n\n/**\n * @type { {\n * render: (opts?: { [key: string]: any }) => string\n * getHtml: (opts?: { [key: string]: any }) => string\n * getCss: (opts?: { [key: string]: any }) => string\n * } }\n */\nconst Template = {\n  render(opts) {\n    return `<style>${this.getCss(opts)}</style>${this.getHtml(opts)}`\n  },\n  getHtml,\n  getCss,\n};\n\nexport { Template };\n","import { convertDashToCamel } from \"../utils/utils.js\"\nimport { Template } from \"./template.js\"\n\nclass DualElement extends HTMLElement {\n  private root = this.attachShadow({ mode: \"open\" })!\n  private opts = { content: \"\" }\n  private dom!: any\n  private connected = false\n  constructor() {\n    super()\n  }\n\n  connectedCallback() {\n    this.root.innerHTML = Template.render(this.opts)\n    this.connected = true\n  }\n\n  static get observedAttributes() {\n    return [\"content\"]\n  }\n\n  attributeChangedCallback(\n    name: string,\n    oldValue: string | null,\n    newValue: string | null\n  ) {\n    if (newValue === oldValue) return\n    switch (name) {\n      case \"content\":\n        this.opts = {\n          ...this.opts,\n          [convertDashToCamel(name)]: newValue || \"\",\n        }\n        if (this.connected)\n          this.root.querySelector(\"div\")!.textContent = this.opts.content\n        break\n      default:\n    }\n  }\n\n  static get is() {\n    return \"dual-element\"\n  }\n}\n\ncustomElements.define(DualElement.is, DualElement)\n\nexport { DualElement }\n"],"names":[],"mappings":"AAeA,SAAS,kBAAkB,CAAC,GAAW;IACrC,OAAO,GAAG,CAAC,OAAO,CAAC,WAAW,EAAE,UAAS,CAAS;QAChD,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,CAAA;KAC1B,CAAC,CAAA;AACJ,CAAC;;;ACnBD;;;;AAIC,SAAS,MAAM,CAAC,IAAI,GAAG,EAAE;IACxB,OAAO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA6CP,CAAA;AACF,CAAC;AAED;;;;AAIC,SAAS,OAAO,CAAC,IAAI,GAAG,EAAE;IACzB,OAAO;0BACiB,IAAI,CAAC,OAAO,QAAQ,CAAA;AAC9C,CAAC;AAED;;;;;;;AAOA,MAAM,QAAQ,GAAG;IACf,MAAM,CAAC,IAAI;QACT,OAAO,UAAU,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,WAAW,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAA;KAClE;IACD,OAAO;IACP,MAAM;CACP,CAAC;AAEF;;AC1EA,MAAM,WAAY,SAAQ,WAAW;IAKnC;QACE,KAAK,EAAE,CAAA;QALD,SAAI,GAAG,IAAI,CAAC,YAAY,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,CAAE,CAAA;QAC3C,SAAI,GAAG,EAAE,OAAO,EAAE,EAAE,EAAE,CAAA;QAEtB,cAAS,GAAG,KAAK,CAAA;KAGxB;IAED,iBAAiB;QACf,IAAI,CAAC,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;QAChD,IAAI,CAAC,SAAS,GAAG,IAAI,CAAA;KACtB;IAED,WAAW,kBAAkB;QAC3B,OAAO,CAAC,SAAS,CAAC,CAAA;KACnB;IAED,wBAAwB,CACtB,IAAY,EACZ,QAAuB,EACvB,QAAuB;QAEvB,IAAI,QAAQ,KAAK,QAAQ;YAAE,OAAM;QACjC,QAAQ,IAAI;YACV,KAAK,SAAS;gBACZ,IAAI,CAAC,IAAI,mCACJ,IAAI,CAAC,IAAI,KACZ,CAAC,kBAAkB,CAAC,IAAI,CAAC,GAAG,QAAQ,IAAI,EAAE,GAC3C,CAAA;gBACD,IAAI,IAAI,CAAC,SAAS;oBAChB,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK,CAAE,CAAC,WAAW,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,CAAA;gBACjE,MAAK;SAER;KACF;IAED,WAAW,EAAE;QACX,OAAO,cAAc,CAAA;KACtB;CACF;AAED,cAAc,CAAC,MAAM,CAAC,WAAW,CAAC,EAAE,EAAE,WAAW,CAAC,CAAA;AAElD;;;;"}